// UniversalObjectiveDataAndContainer.zs

// Single struct to hold objective data

class VUOS_ObjectiveData
{
    String objectiveDescription; // Description text displayed to the player
    name targetClass;            // Class name of the target actor (e.g. 'DoomImp')
    int targetCount;             // Number of targets required to complete
    int currentCount;            // Current progress toward targetCount
    int objectiveType;           // 0 = kill (WorldThingDied), 1 = destroy (WorldThingDestroyed), 2 = collect (inventory poll), 3 = custom
    bool isHidden;               // If true, objective is not shown on HUD
    bool isCompleted;            // Whether this objective has been completed
    bool hasFailed;              // Whether this objective has failed
    bool isInverse;              // If true, FAIL when target reached instead of completing
    String mapName;              // Track which map this objective belongs to
    bool persist;                // If false, objective is deleted when leaving its map
    int timer;                   // For fade-out animation after completion/failure
    int timeLimit;               // Time limit in tics (35 tics = 1 second), 0 = no time limit
    int timeRemaining;           // Remaining time in tics
    bool isPrimary;              // If true, primary objective (green header), else secondary (grey header)
    bool requiredToComplete;     // If true, must be completed before exiting map
    int minSkillLevel;           // Minimum skill level for this objective (0-4, default 0 = all skills)
    int maxSkillLevel;           // Maximum skill level for this objective (0-4, default 4 = all skills)
    
    // Waypoint / spatial data
    vector3 waypointPos;    // World position for this objective's waypoint (primary/closest position)
    bool hasWaypoint;       // Whether this objective has a spatial location (false if waypoint is at origin 0,0,0)
    Array<int> cachedDistances; // Per-player cached distances in map units, updated periodically in WorldTick
    Actor markerActor;      // Reference to automap marker actor for this objective
    bool isTracked;         // If true, objective appears on waypoints, compass, and HUD (default: true)

    // Multi-position waypoint data (for objectives with multiple locations, e.g. duplicate keys, multiple exits)
    // ZScript does not support Array<vector3>, so positions are stored as three parallel double arrays.
    Array<double> wpPosX;               // X coordinates for all waypoint positions
    Array<double> wpPosY;               // Y coordinates for all waypoint positions
    Array<double> wpPosZ;               // Z coordinates for all waypoint positions
    Array<Actor> trackedActors;         // Parallel array: actor references for position cleanup (bosses, keys)
    Array<Actor> markerActors;          // Parallel array: automap marker actors for each position

    // Auto-generated objective identification
    // Must NOT be transient — needs to survive save/load serialization
    bool isAutoGenerated;   // If true, this objective was created by VUOS_AutoObjectives

    // Get cached distance for a specific player (multiplayer-safe)
    int GetDistance(int playerNum)
    {
        if (playerNum >= 0 && playerNum < cachedDistances.Size())
            return cachedDistances[playerNum];
        return 0;
    }

    // Set cached distance for a specific player (auto-grows array if needed)
    void SetDistance(int playerNum, int dist)
    {
        while (cachedDistances.Size() <= playerNum)
            cachedDistances.Push(0);
        cachedDistances[playerNum] = dist;
    }

    // Check if this objective is valid for the current game skill level
    // Uses G_SkillPropertyInt(SKILLP_ACSReturn) which returns 0-4 for standard Doom skills:
    //   0 = "I'm too young to die" (ITYTD)
    //   1 = "Hey, not too rough" (HNTR)
    //   2 = "Hurt me plenty" (HMP)
    //   3 = "Ultra-Violence" (UV)
    //   4 = "Nightmare!" (NM)
    // Pass skill >= 0 to avoid redundant G_SkillPropertyInt() calls in loops.
    bool IsValidForCurrentSkill(int skill = -1)
    {
        if (skill < 0) skill = G_SkillPropertyInt(SKILLP_ACSReturn);
        return (skill >= minSkillLevel && skill <= maxSkillLevel);
    }

    // ================================================================
    // MULTI-POSITION ACCESSORS
    // ================================================================

    // Get number of waypoint positions stored
    clearscope int GetWaypointPositionCount()
    {
        return wpPosX.Size();
    }

    // Get a waypoint position by index as vector3
    clearscope vector3 GetWaypointPosition(int index)
    {
        if (index >= 0 && index < wpPosX.Size())
            return (wpPosX[index], wpPosY[index], wpPosZ[index]);
        return waypointPos;
    }

    // Push a new waypoint position
    void PushWaypointPosition(double x, double y, double z)
    {
        wpPosX.Push(x);
        wpPosY.Push(y);
        wpPosZ.Push(z);
    }

    // Clear all waypoint positions
    void ClearWaypointPositions()
    {
        wpPosX.Clear();
        wpPosY.Clear();
        wpPosZ.Clear();
    }

    // Delete a waypoint position by index
    void DeleteWaypointPosition(int index)
    {
        if (index >= 0 && index < wpPosX.Size())
        {
            wpPosX.Delete(index);
            wpPosY.Delete(index);
            wpPosZ.Delete(index);
        }
    }

    // Get the closest waypoint position to a given point (for multi-position objectives)
    // Returns the index in the position arrays, or -1 if no positions exist
    // clearscope: called from both UI (compass/waypoints) and play (automap refresh) contexts
    clearscope int GetClosestPositionIndex(vector3 fromPos)
    {
        if (wpPosX.Size() == 0) return -1;
        if (wpPosX.Size() == 1) return 0;

        int closest = 0;
        // Use raw vector subtraction for distance (portal-safe not needed for closest comparison)
        vector3 d0 = (wpPosX[0] - fromPos.X, wpPosY[0] - fromPos.Y, wpPosZ[0] - fromPos.Z);
        double closestDist = d0.Length();
        for (int i = 1; i < wpPosX.Size(); i++)
        {
            vector3 di = (wpPosX[i] - fromPos.X, wpPosY[i] - fromPos.Y, wpPosZ[i] - fromPos.Z);
            double dist = di.Length();
            if (dist < closestDist)
            {
                closestDist = dist;
                closest = i;
            }
        }
        return closest;
    }

    // Remove a waypoint position by matching coordinates (for static actors like keys)
    // Returns true if a position was found and removed
    // Does NOT destroy marker actors (data context can't call play functions).
    // Caller must call MarkMarkersDirty() so RefreshAllMarkers rebuilds markers at updated positions.
    bool RemoveWaypointByPosition(vector3 pos, double tolerance = 1.0)
    {
        for (int i = 0; i < wpPosX.Size(); i++)
        {
            vector3 diff = (wpPosX[i] - pos.X, wpPosY[i] - pos.Y, wpPosZ[i] - pos.Z);
            if (diff.Length() < tolerance)
            {
                DeleteWaypointPosition(i);
                if (i < trackedActors.Size()) trackedActors.Delete(i);
                // Don't touch markerActors here - RefreshAllMarkers will rebuild all markers
                UpdatePrimaryWaypoint();
                return true;
            }
        }
        return false;
    }

    // Remove a waypoint position by matching the tracked actor reference (for moving actors like bosses)
    // Returns true if a position was found and removed
    // Does NOT destroy marker actors (data context can't call play functions).
    // Caller must call MarkMarkersDirty() so RefreshAllMarkers rebuilds markers at updated positions.
    bool RemoveWaypointByActor(Actor act)
    {
        for (int i = 0; i < trackedActors.Size(); i++)
        {
            if (trackedActors[i] == act)
            {
                if (i < wpPosX.Size()) DeleteWaypointPosition(i);
                trackedActors.Delete(i);
                // Don't touch markerActors here - RefreshAllMarkers will rebuild all markers
                UpdatePrimaryWaypoint();
                return true;
            }
        }
        return false;
    }

    // Update the primary waypointPos from remaining positions array
    // Called after removing a position to keep waypointPos/hasWaypoint in sync
    void UpdatePrimaryWaypoint()
    {
        if (wpPosX.Size() > 0)
        {
            waypointPos = (wpPosX[0], wpPosY[0], wpPosZ[0]);
            hasWaypoint = true;
        }
        else
        {
            waypointPos = (0, 0, 0);
            hasWaypoint = false;
        }
        cachedDistances.Clear();
    }

    // Check if this objective should be visible on the current map.
    // Combines the three most common filter checks: map match, hidden state, and skill validity.
    // Pass skill >= 0 to avoid redundant G_SkillPropertyInt() calls in loops.
    bool IsVisibleForCurrentMap(int skill = -1)
    {
        if (!(mapName ~== level.MapName)) return false;
        if (isHidden) return false;
        return IsValidForCurrentSkill(skill);
    }
}

// Per-frame rendering settings populated once in RenderOverlay
// Passed to compass, waypoints, and other UI drawing methods to avoid
// redundant CVar lookups every frame across multiple classes.
class VUOS_RenderSettings
{
    // Shared settings (used by compass + waypoints + renderer)
    int distanceUnits;       // 0 = map units, 1 = meters
    int primaryColorIdx;     // Font.CR_ index for primary header
    int secondaryColorIdx;   // Font.CR_ index for secondary header

    // Compass settings
    bool compassShow;
    int compassStyle;        // 0 = procedural, 1 = textured
    double compassOpacity;
    int compassOffsetX;
    int compassOffsetY;
    int compassFOV;
    double compassScale;
    bool compassShowDistance;
    double compassTextScale;
    bool compassShowBearing;  // Show azimuth bearing numbers (0-360) at tick positions
    int compassBearingInterval; // Degrees between bearing numbers (15, 30, 60, or 90)

    // Waypoint settings
    double waypointScale;
    int waypointMaxDistance;
    double waypointTextScale;
    int waypointStyle;       // 0 = procedural, 1 = textured
    int waypointMultiMode;   // 0 = show closest, 1 = show all (for compass + waypoints)
    int automapMultiMode;    // 0 = show closest, 1 = show all (for automap markers)

    // Refresh all CVar values in-place (called once per frame from RenderOverlay).
    // Avoids per-frame allocation — the single VUOS_RenderSettings instance is
    // created once on the renderer and reused every frame.
    void Refresh()
    {
        let p = players[consoleplayer];

        // Shared
        distanceUnits = VUOS_ObjectiveHandler.GetCVarInt('obj_distance_units', p, 1);
        primaryColorIdx = VUOS_ObjectiveHandler.GetCVarInt('obj_color_primary_header', p, 3);
        secondaryColorIdx = VUOS_ObjectiveHandler.GetCVarInt('obj_color_secondary_header', p, 21);

        // Compass
        compassShow = VUOS_ObjectiveHandler.GetCVarBool('obj_compass_show', p, true);
        compassStyle = VUOS_ObjectiveHandler.GetCVarInt('obj_compass_style', p, 0);
        compassOpacity = VUOS_ObjectiveHandler.GetCVarFloat('obj_compass_opacity', p, 0.90);
        compassOffsetX = VUOS_ObjectiveHandler.GetCVarInt('obj_compass_offset_x', p, 0);
        compassOffsetY = VUOS_ObjectiveHandler.GetCVarInt('obj_compass_offset_y', p, 0);
        compassFOV = VUOS_ObjectiveHandler.GetCVarInt('obj_compass_fov', p, 180);
        if (compassFOV < 45) compassFOV = 45;
        if (compassFOV > 360) compassFOV = 360;
        compassScale = VUOS_ObjectiveHandler.GetCVarFloat('obj_compass_scale', p, 0.75);
        if (compassScale < 0.5) compassScale = 0.5;
        if (compassScale > 2.0) compassScale = 2.0;
        compassShowDistance = VUOS_ObjectiveHandler.GetCVarBool('obj_compass_show_distance', p, true);
        compassTextScale = VUOS_ObjectiveHandler.GetCVarFloat('obj_compass_text_scale', p, 0.75);
        if (compassTextScale < 0.5) compassTextScale = 0.5;
        if (compassTextScale > 3.0) compassTextScale = 3.0;
        compassShowBearing = VUOS_ObjectiveHandler.GetCVarBool('obj_compass_show_bearing', p, true);
        compassBearingInterval = VUOS_ObjectiveHandler.GetCVarInt('obj_compass_bearing_interval', p, 30);
        if (compassBearingInterval != 15 && compassBearingInterval != 30 && compassBearingInterval != 60 && compassBearingInterval != 90)
            compassBearingInterval = 30;

        // Waypoints
        waypointScale = VUOS_ObjectiveHandler.GetCVarFloat('obj_waypoint_scale', p, 1.0);
        if (waypointScale < 0.25) waypointScale = 0.25;
        if (waypointScale > 3.0) waypointScale = 3.0;
        waypointMaxDistance = VUOS_ObjectiveHandler.GetCVarInt('obj_waypoint_max_distance', p, 0);
        if (waypointMaxDistance > 0 && distanceUnits == 1)
            waypointMaxDistance *= 32;
        waypointTextScale = VUOS_ObjectiveHandler.GetCVarFloat('obj_waypoint_text_scale', p, 0.75);
        if (waypointTextScale < 0.5) waypointTextScale = 0.5;
        if (waypointTextScale > 3.0) waypointTextScale = 3.0;
        waypointStyle = VUOS_ObjectiveHandler.GetCVarInt('obj_waypoint_style', p, 0);
        waypointMultiMode = VUOS_ObjectiveHandler.GetCVarInt('vuos_waypoint_multi_mode', p, 0);
        automapMultiMode = VUOS_ObjectiveHandler.GetCVarInt('vuos_automap_multi_mode', p, 0);
    }
}